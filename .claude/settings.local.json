{
  "permissions": {
    "allow": [
      "Bash(npx create-expo-app@latest:*)",
      "Bash(del \"C:\\\\Users\\\\touti\\\\OneDrive\\\\Desktop\\\\hackathon\\\\frontend\\\\frontreadme.md\")",
      "Bash(npm install:*)",
      "Bash(\"C:\\\\Users\\\\touti\\\\OneDrive\\\\Desktop\\\\hackathon\\\\frontend\\\\generate-avatars.js\" << 'SCRIPT_EOF'\nconst zlib = require\\('zlib'\\);\nconst fs = require\\('fs'\\);\nconst path = require\\('path'\\);\n\n// CRC32 lookup table\nconst crcTable = [];\nfor \\(let n = 0; n < 256; n++\\) {\n  let c = n;\n  for \\(let k = 0; k < 8; k++\\) {\n    c = \\(c & 1\\) ? \\(0xedb88320 ^ \\(c >>> 1\\)\\) : \\(c >>> 1\\);\n  }\n  crcTable[n] = c;\n}\n\nfunction crc32\\(buf\\) {\n  let crc = 0xffffffff;\n  for \\(let i = 0; i < buf.length; i++\\) {\n    crc = crcTable[\\(crc ^ buf[i]\\) & 0xff] ^ \\(crc >>> 8\\);\n  }\n  return \\(crc ^ 0xffffffff\\) >>> 0;\n}\n\nfunction createChunk\\(type, data\\) {\n  const typeBytes = Buffer.from\\(type, 'ascii'\\);\n  const length = Buffer.alloc\\(4\\);\n  length.writeUInt32BE\\(data.length, 0\\);\n\n  const crcInput = Buffer.concat\\([typeBytes, data]\\);\n  const crcVal = Buffer.alloc\\(4\\);\n  crcVal.writeUInt32BE\\(crc32\\(crcInput\\), 0\\);\n\n  return Buffer.concat\\([length, typeBytes, data, crcVal]\\);\n}\n\nfunction createPNG\\(r, g, b, size\\) {\n  // PNG signature\n  const signature = Buffer.from\\([137, 80, 78, 71, 13, 10, 26, 10]\\);\n\n  // IHDR chunk: width, height, bit depth \\(8\\), color type \\(2=RGB\\)\n  const ihdrData = Buffer.alloc\\(13\\);\n  ihdrData.writeUInt32BE\\(size, 0\\);\n  ihdrData.writeUInt32BE\\(size, 4\\);\n  ihdrData[8] = 8;\n  ihdrData[9] = 2;\n  ihdrData[10] = 0;\n  ihdrData[11] = 0;\n  ihdrData[12] = 0;\n  const ihdr = createChunk\\('IHDR', ihdrData\\);\n\n  // Raw image data: each row has a filter byte \\(0\\) followed by RGB pixels\n  const rowSize = 1 + size * 3;\n  const rawData = Buffer.alloc\\(rowSize * size\\);\n  for \\(let y = 0; y < size; y++\\) {\n    const offset = y * rowSize;\n    rawData[offset] = 0;\n    for \\(let x = 0; x < size; x++\\) {\n      const px = offset + 1 + x * 3;\n      rawData[px] = r;\n      rawData[px + 1] = g;\n      rawData[px + 2] = b;\n    }\n  }\n\n  const compressed = zlib.deflateSync\\(rawData\\);\n  const idat = createChunk\\('IDAT', compressed\\);\n\n  // IEND chunk\n  const iend = createChunk\\('IEND', Buffer.alloc\\(0\\)\\);\n\n  return Buffer.concat\\([signature, ihdr, idat, iend]\\);\n}\n\nconst outputDir = path.join\\(__dirname, 'src', 'assets', 'avatars'\\);\n\nconst avatars = [\n  { name: 'villager.png',          r: 76,  g: 175, b: 80  },\n  { name: 'equipped-villager.png',  r: 33,  g: 150, b: 243 },\n  { name: 'warrior.png',           r: 255, g: 152, b: 0   },\n  { name: 'knight.png',            r: 255, g: 215, b: 0   },\n];\n\nconst SIZE = 64;\n\nfor \\(const avatar of avatars\\) {\n  const png = createPNG\\(avatar.r, avatar.g, avatar.b, SIZE\\);\n  const filePath = path.join\\(outputDir, avatar.name\\);\n  fs.writeFileSync\\(filePath, png\\);\n  console.log\\('Created: ' + filePath + ' \\(' + png.length + ' bytes\\)'\\);\n}\n\nconsole.log\\('\\\\nAll avatar placeholders generated successfully.'\\);\nSCRIPT_EOF)",
      "Bash(node:*)",
      "Bash(npx expo export:*)",
      "Bash(npx expo start)",
      "Bash(npx expo install:*)"
    ]
  }
}
